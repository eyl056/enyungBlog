---
title: "[백준 1149번 파이썬] RGB거리"
date: 2020-02-23
categories: baekjoon
---

<br><br>
[백준 1149번 RGB거리](https://www.acmicpc.net/problem/1149)
<br><br><br>

### 문제<br>

RGB거리에는 집이 N개 있다. 거리는 선분으로 나타낼 수 있고, 1번 집부터 N번 집이 순서대로 있다.

집은 빨강, 초록, 파랑 중 하나의 색으로 칠해야 한다. 각각의 집을 빨강, 초록, 파랑으로 칠하는 비용이 주어졌을 때, 아래 규칙을 만족하면서 모든 집을 칠하는 비용의 최솟값을 구해보자.

- 1번 집의 색은 2번 집의 색과 같지 않아야 한다.
- N번 집의 색은 N-1번 집의 색과 같지 않아야 한다.
- i(2 ≤ i ≤ N-1)번 집의 색은 i-1번, i+1번 집의 색과 같지 않아야 한다.

<br><br><br>

### 입력<br>

첫째 줄에 집의 수 N(2 ≤ N ≤ 1,000)이 주어진다. 둘째 줄부터 N개의 줄에는 각 집을 빨강, 초록, 파랑으로 칠하는 비용이 1번 집부터 한 줄에 하나씩 주어진다. 집을 칠하는 비용은 1,000보다 작거나 같은 자연수이다.


<br><br><br>

### 출력<br>

첫째 줄에 모든 집을 칠하는 비용의 최솟값을 출력한다.

<br><br><br>

### 나의 풀이 방법<br>

예제 참고 <br>

|  cost  |   빨강    |   초록    |   파랑    |
| :----: | :-------: | :-------: | :-------: |
| 1번 집 |    26     |    40     |    83     |
| 2번 집 | <u>49</u> | <u>60</u> | <u>57</u> |
| 3번 집 |    13     |    89     |    99     |



```python
for i in range(1, N):  # i == 1일 때
    	# 빨강 49 선택 -> 초록 40, 파랑 83 중 작은 값 선택
        dp[i][0] = cost[i][0] + min(dp[i - 1][1], dp[i - 1][2])
        # 초록 60 선택 -> 빨강 26, 파랑 83 중 작은 값 선택
        dp[i][1] = cost[i][1] + min(dp[i - 1][0], dp[i - 1][2])
        # 파랑 57 선택 -> 빨강 26, 초록 40 중 작은 값 선택
        dp[i][2] = cost[i][2] + min(dp[i - 1][0], dp[i - 1][1])
```



|    dp    |       빨강       |       초록       |       파랑       |
| :------: | :--------------: | :--------------: | :--------------: |
|  i == 0  |        26        |        40        |        83        |
|  i == 1  | 49 + min(40, 83) | 60 + min(26, 83) | 57 + min(26, 40) |
| i == ... |                  |                  |                  |



<br><br><br>


### 코드(python3)
```python
import sys
input = sys.stdin.readline


def main():
    N = int(input().strip())
    cost = []
    for _ in range(N):
        price = list(map(int, input().split()))
        cost.append(price)

    # print(cost)  # [[26, 40, 83], [49, 60, 57], [13, 89, 99]]
    dp = cost
    for i in range(1, N):
        dp[i][0] = cost[i][0] + min(dp[i - 1][1], dp[i - 1][2])
        dp[i][1] = cost[i][1] + min(dp[i - 1][0], dp[i - 1][2])
        dp[i][2] = cost[i][2] + min(dp[i - 1][0], dp[i - 1][1])

    print(min(dp[N - 1]))


if __name__ == "__main__":
    main()
```
